name: Publish Dummy Docker Artifacts to JFrog

on:
  # Manual trigger only
  workflow_dispatch:
    inputs:
      build_version:
        description: 'Build version (commit SHA or custom version)'
        required: false
        default: 'test-dummy'
      registry_environment:
        description: 'Target registry environment'
        type: choice
        options:
          - dev
          - staging
          - prod
        default: dev
  push:
    branches:
      - development

env:
  # Build versioning
  BUILD_VERSION: ${{ inputs.build_version || 'test-dummy' }}
  BUILD_NUMBER: ${{ github.run_number }}
  REGISTRY_ENV: ${{ inputs.registry_environment || 'dev' }}

jobs:
  publish-dummy-artifacts:
    name: Publish Dummy Docker Artifacts
    runs-on: [self-hosted, onlysaid-runner]
    timeout-minutes: 30
    
    steps:
      # 1. Setup & Environment Configuration
      - name: "[CONFIG] Load environment configuration"
        id: config
        run: |
          echo "🔧 Loading configuration for ${{ env.REGISTRY_ENV }} environment..."
          
          SECRETS_FILE="$HOME/.secrets"
          if [ -f "$SECRETS_FILE" ]; then
            echo "Loading environment variables from $SECRETS_FILE..."
            source "$SECRETS_FILE"
            
            # Export to GitHub Actions environment
            echo "JFROG_URL=${JFROG_URL}" >> $GITHUB_ENV
            echo "JFROG_USER=${JFROG_USER}" >> $GITHUB_ENV
            echo "JFROG_USER_PASSWORD=${JFROG_USER_PASSWORD}" >> $GITHUB_ENV
            
            # Configure registry based on environment using Repository Path method
            ARTIFACTORY_HOST=$(echo "${JFROG_URL}" | sed 's|^https\?://||' | sed 's|/$||')
            case "${{ env.REGISTRY_ENV }}" in
              "dev")
                DOCKER_REPO="oa-onlysaid-app-docker-dev-local"
                ;;
              "staging")
                DOCKER_REPO="oa-onlysaid-app-docker-staging-local"
                ;;
              "prod")
                DOCKER_REPO="oa-onlysaid-app-docker-prod-local"
                ;;
              *)
                echo "❌ Unknown registry environment: ${{ env.REGISTRY_ENV }}"
                exit 1
                ;;
            esac
            
            echo "DOCKER_REPO=${DOCKER_REPO}" >> $GITHUB_ENV
            echo "ARTIFACTORY_HOST=${ARTIFACTORY_HOST}" >> $GITHUB_ENV
            
            echo "✅ Configuration loaded successfully"
            echo "Environment: ${{ env.REGISTRY_ENV }}"
            echo "JFrog URL: ${JFROG_URL}"
            echo "Artifactory Host: ${ARTIFACTORY_HOST}"
            echo "Docker Repository: ${DOCKER_REPO}"
            echo "JFrog User: ${JFROG_USER}"
          else
            echo "❌ Secrets file not found at $SECRETS_FILE"
            exit 1
          fi

      - name: "[VERIFY] Environment and connectivity"
        run: |
          echo "🔍 Verifying environment..."
          echo "Runner OS: $(uname -a)"
          echo "Docker version: $(docker --version)"
          echo "Current user: $(whoami)"
          echo "Available disk space:"
          df -h /tmp
          
          echo "🔗 Testing JFrog connectivity..."
          
          # Test JFrog web interface (for API calls)
          WEB_URL="${JFROG_URL%/}/artifactory/api/system/ping"
          echo "Testing JFrog web interface: ${WEB_URL}"
          
          RETRY_COUNT=0
          MAX_RETRIES=3
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s -k --connect-timeout 10 --max-time 30 "${WEB_URL}" > /dev/null; then
              echo "✅ JFrog web interface is accessible (attempt $((RETRY_COUNT + 1)))"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠️ JFrog web interface connectivity failed, retrying in 5 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 5
              else
                echo "❌ Cannot reach JFrog web interface after $MAX_RETRIES attempts"
                echo "JFrog URL: ${JFROG_URL}"
                exit 1
              fi
            fi
          done
          
          # Test JFrog Artifactory (use same URL as web interface)
          ARTIFACTORY_URL="${JFROG_URL%/}/artifactory/api/system/ping"
          echo "Testing JFrog Artifactory: ${ARTIFACTORY_URL}"
          
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s -k --connect-timeout 10 --max-time 30 "${ARTIFACTORY_URL}" > /dev/null; then
              echo "✅ JFrog Artifactory is accessible (attempt $((RETRY_COUNT + 1)))"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠️ JFrog Artifactory connectivity failed, retrying in 5 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 5
              else
                echo "❌ Cannot reach JFrog Artifactory after $MAX_RETRIES attempts"
                echo "JFrog Artifactory URL: ${JFROG_URL}"
                exit 1
              fi
            fi
          done

      # Replace the image creation step to build with proper registry tags
      - name: "[CREATE] Dummy Docker images"
        run: |
          echo "🏗️ Creating dummy Docker images for testing..."
          
          # Create simple dummy images
          IMAGES=("onlysaid-app" "onlysaid-socket" "onlysaid-kb" "onlysaid-docs")
          
          for image in "${IMAGES[@]}"; do
            echo "Creating dummy $image image..."
            
            # Create a simple Dockerfile for dummy image
            cat > /tmp/Dockerfile.${image} << EOF
          FROM alpine:latest
          LABEL version="${{ env.BUILD_VERSION }}"
          LABEL environment="${{ env.REGISTRY_ENV }}"
          LABEL image-name="${image}"
          LABEL created-by="github-actions"
          LABEL created-at="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          RUN echo "Dummy ${image} image for testing JFrog publishing" > /app.txt
          RUN echo "Version: ${{ env.BUILD_VERSION }}" >> /app.txt
          RUN echo "Environment: ${{ env.REGISTRY_ENV }}" >> /app.txt
          CMD ["cat", "/app.txt"]
          EOF
            
            # Build dummy image with Repository Path format: <HOST>/<REPO>/<IMAGE>:<TAG>
            FULL_IMAGE_NAME="${{ env.ARTIFACTORY_HOST }}/${{ env.DOCKER_REPO }}/${image}"
            
            docker build -f /tmp/Dockerfile.${image} -t "${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}" .
            docker tag "${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}" "${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-latest"
            
            echo "✅ Created dummy $image image"
            echo "   Version tag: ${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}"
            echo "   Latest tag: ${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-latest"
          done
          
          echo "📋 Created dummy images:"
          docker images | grep "${{ env.ARTIFACTORY_HOST }}"

      # Add a diagnostic step before the push step
      - name: "[DIAGNOSE] JFrog Repository Health Check"
        run: |
          echo "🔍 Diagnosing JFrog repository configuration..."
          
          # Test repository accessibility via REST API
          REPO_URL="${JFROG_URL%/}/artifactory/api/repositories/${{ env.DOCKER_REPO }}"
          echo "Testing repository: $REPO_URL"
          
          if curl -f -s -k -u "${{ env.JFROG_USER }}:${{ env.JFROG_USER_PASSWORD }}" "$REPO_URL" > /tmp/repo_info.json; then
            echo "✅ Repository is accessible via API"
            echo "Repository info:"
            cat /tmp/repo_info.json | jq '.' || cat /tmp/repo_info.json
          else
            echo "❌ Repository not accessible via API"
            echo "This might indicate:"
            echo "1. Repository doesn't exist"
            echo "2. User doesn't have permissions"
            echo "3. Repository is not a Docker repository"
          fi
          
          # Test Docker registry v2 API
          DOCKER_V2_URL="https://${{ env.ARTIFACTORY_HOST }}/v2/"
          echo "Testing Docker v2 API: $DOCKER_V2_URL"
          
          if curl -f -s -k -u "${{ env.JFROG_USER }}:${{ env.JFROG_USER_PASSWORD }}" "$DOCKER_V2_URL" > /dev/null; then
            echo "✅ Docker v2 API is accessible"
          else
            echo "❌ Docker v2 API not accessible"
          fi
          
          # Test specific repository endpoint
          REPO_V2_URL="https://${{ env.ARTIFACTORY_HOST }}/v2/${{ env.DOCKER_REPO }}/tags/list"
          echo "Testing repository v2 endpoint: $REPO_V2_URL"
          
          if curl -f -s -k -u "${{ env.JFROG_USER }}:${{ env.JFROG_USER_PASSWORD }}" "$REPO_V2_URL"; then
            echo "✅ Repository v2 endpoint is accessible"
          else
            echo "❌ Repository v2 endpoint not accessible"
          fi

      # Modify the push step with better error handling and smaller images
      - name: "[PUBLISH] Push Docker images to JFrog Registry"
        run: |
          echo "🚀 Pushing Docker images to JFrog Artifactory using Repository Path method..."
          
          echo "Artifactory Host: ${{ env.ARTIFACTORY_HOST }}"
          echo "Docker Repository: ${{ env.DOCKER_REPO }}"
          echo "JFrog User: ${{ env.JFROG_USER }}"
          
          # Configure Docker for insecure registry with better settings
          sudo mkdir -p /etc/docker
          
          # Backup existing daemon.json if it exists
          if [ -f /etc/docker/daemon.json ]; then
            sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.backup
          fi
          
          # Create daemon.json for insecure registry with optimized settings
          sudo tee /etc/docker/daemon.json > /dev/null << EOF
          {
            "insecure-registries": ["${{ env.ARTIFACTORY_HOST }}"],
            "registry-mirrors": [],
            "debug": false,
            "max-concurrent-uploads": 1,
            "max-concurrent-downloads": 1,
            "max-download-attempts": 5,
            "storage-driver": "overlay2",
            "storage-opts": [
              "overlay2.override_kernel_check=true"
            ]
          }
          EOF
          
          echo "📋 Docker daemon configuration:"
          sudo cat /etc/docker/daemon.json
          
          # Restart Docker daemon with longer wait
          echo "🔄 Restarting Docker daemon..."
          sudo systemctl restart docker
          sleep 30
          
          # Verify Docker is working
          echo "✅ Verifying Docker status..."
          docker version
          docker info | grep -E "(Storage Driver|Registry)"
          
          # Docker login using Repository Path method with retry logic
          echo "🔐 Authenticating with JFrog Docker registry..."
          echo "Login command: docker login ${{ env.ARTIFACTORY_HOST }} -u ${{ env.JFROG_USER }}"
          
          LOGIN_ATTEMPTS=0
          MAX_LOGIN_ATTEMPTS=3
          
          while [ $LOGIN_ATTEMPTS -lt $MAX_LOGIN_ATTEMPTS ]; do
            if echo "${{ env.JFROG_USER_PASSWORD }}" | docker login "${{ env.ARTIFACTORY_HOST }}" -u "${{ env.JFROG_USER }}" --password-stdin; then
              echo "✅ Successfully authenticated with JFrog Docker Registry"
              break
            else
              LOGIN_ATTEMPTS=$((LOGIN_ATTEMPTS + 1))
              if [ $LOGIN_ATTEMPTS -lt $MAX_LOGIN_ATTEMPTS ]; then
                echo "⚠️ Login attempt $LOGIN_ATTEMPTS failed, retrying in 10 seconds..."
                sleep 10
              else
                echo "❌ Failed to authenticate after $MAX_LOGIN_ATTEMPTS attempts"
                exit 1
              fi
            fi
          done
          
          # Test repository access before pushing
          echo "🔍 Testing repository access..."
          REPO_TEST_URL="https://${{ env.ARTIFACTORY_HOST }}/v2/${{ env.DOCKER_REPO }}/tags/list"
          if curl -f -s -k -u "${{ env.JFROG_USER }}:${{ env.JFROG_USER_PASSWORD }}" "$REPO_TEST_URL" > /dev/null; then
            echo "✅ Repository is accessible via Docker v2 API"
          else
            echo "❌ Repository not accessible - this may cause push failures"
            echo "Repository URL: $REPO_TEST_URL"
            # Continue anyway to see detailed error
          fi
          
          # Function to push with retry logic
          push_with_retry() {
            local image_tag="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Pushing $image_tag"
              
              if timeout 600 docker push "$image_tag" 2>&1 | tee /tmp/push_log_${attempt}.txt; then
                echo "✅ Successfully pushed $image_tag on attempt $attempt"
                return 0
              else
                echo "❌ Push attempt $attempt failed for $image_tag"
                
                # Analyze the error
                if grep -q "blob upload unknown" /tmp/push_log_${attempt}.txt; then
                  echo "Error: 'blob upload unknown' detected"
                  echo "This usually indicates:"
                  echo "1. Repository is not properly configured as a Docker repository"
                  echo "2. User lacks push permissions"
                  echo "3. Repository path is incorrect"
                  echo "4. JFrog Artifactory Docker service configuration issue"
                fi
                
                if grep -q "unauthorized" /tmp/push_log_${attempt}.txt; then
                  echo "Error: 'unauthorized' - Authentication or permission issue"
                fi
                
                if grep -q "timeout\|connection reset\|EOF" /tmp/push_log_${attempt}.txt; then
                  echo "Error: Network connectivity issue detected"
                fi
                
                if [ $attempt -lt $max_attempts ]; then
                  echo "Waiting 30 seconds before retry..."
                  sleep 30
                fi
                
                attempt=$((attempt + 1))
              fi
            done
            
            echo "❌ Failed to push $image_tag after $max_attempts attempts"
            return 1
          }
          
          # Try pushing just one image first as a test
          echo "🧪 Testing with single image push first..."
          TEST_IMAGE="onlysaid-app"
          FULL_IMAGE_NAME="${{ env.ARTIFACTORY_HOST }}/${{ env.DOCKER_REPO }}/${TEST_IMAGE}"
          VERSION_TAG="${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}"
          
          echo "Test push: $VERSION_TAG"
          
          # Try to push with retry logic (remove --debug flag)
          if push_with_retry "$VERSION_TAG"; then
            echo "✅ Test push successful!"
            
            # If test push works, proceed with all images
            IMAGES=("onlysaid-app" "onlysaid-socket" "onlysaid-kb" "onlysaid-docs")
            PUSHED_COUNT=1  # Already pushed test image
            FAILED_PUSHES=()
            
            # Skip the first image since we already pushed it
            for image in "${IMAGES[@]:1}"; do
              echo "📤 Pushing $image..."
              
              FULL_IMAGE_NAME="${{ env.ARTIFACTORY_HOST }}/${{ env.DOCKER_REPO }}/${image}"
              VERSION_TAG="${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}"
              LATEST_TAG="${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-latest"
              
              echo "Pushing: $VERSION_TAG"
              echo "Pushing: $LATEST_TAG"
              
              # Push with retry logic
              if push_with_retry "${VERSION_TAG}" && push_with_retry "${LATEST_TAG}"; then
                echo "✅ Successfully pushed $image"
                PUSHED_COUNT=$((PUSHED_COUNT + 1))
              else
                echo "❌ Failed to push $image"
                FAILED_PUSHES+=("$image")
              fi
              echo "---"
            done
            
            # Also push the latest tag for the test image
            LATEST_TAG="${{ env.ARTIFACTORY_HOST }}/${{ env.DOCKER_REPO }}/${TEST_IMAGE}:${{ env.REGISTRY_ENV }}-latest"
            echo "Pushing latest tag for test image: $LATEST_TAG"
            push_with_retry "$LATEST_TAG" || echo "Failed to push latest tag for test image"
            
          else
            echo "❌ Test push failed!"
            echo "🔍 Detailed error analysis:"
            
            # Show all push logs
            for log_file in /tmp/push_log_*.txt; do
              if [ -f "$log_file" ]; then
                echo "=== $log_file ==="
                cat "$log_file"
                echo "=================="
              fi
            done
            
            echo ""
            echo "🚨 TROUBLESHOOTING STEPS:"
            echo "1. Verify the Docker repository '${{ env.DOCKER_REPO }}' exists in JFrog"
            echo "2. Check that the repository is configured as a Docker repository (not generic)"
            echo "3. Verify user '${{ env.JFROG_USER }}' has push permissions to this repository"
            echo "4. Check JFrog Artifactory Docker service is running properly"
            echo "5. Verify the repository path format is correct"
            echo ""
            echo "Repository URL: https://${{ env.ARTIFACTORY_HOST }}/ui/repos/tree/General/${{ env.DOCKER_REPO }}"
            
            exit 1
          fi
          
          # Report results
          echo "📊 Push Results:"
          echo "Successfully pushed: $PUSHED_COUNT/${#IMAGES[@]}"
          
          if [ ${#FAILED_PUSHES[@]} -gt 0 ]; then
            echo "Failed pushes: ${FAILED_PUSHES[*]}"
            echo "❌ Some images failed to push"
            exit 1
          else
            echo "✅ All images pushed successfully"
          fi

      # 4. Verify published images
      - name: "[VERIFY] Published images"
        run: |
          echo "🔍 Verifying published images in JFrog..."
          
          IMAGES=("onlysaid-app" "onlysaid-socket" "onlysaid-kb" "onlysaid-docs")
          VERIFIED_COUNT=0
          
          for image in "${IMAGES[@]}"; do
            FULL_IMAGE_NAME="${{ env.ARTIFACTORY_HOST }}/${{ env.DOCKER_REPO }}/${image}"
            IMAGE_URL="${FULL_IMAGE_NAME}:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}"
            echo "Checking $IMAGE_URL..."
            
            # Use docker manifest inspect to verify the image exists
            if docker manifest inspect "$IMAGE_URL" > /dev/null 2>&1; then
              echo "✅ $image verified successfully"
              VERIFIED_COUNT=$((VERIFIED_COUNT + 1))
            else
              echo "❌ $image verification failed"
            fi
          done
          
          echo "📊 Verification Results: $VERIFIED_COUNT/${#IMAGES[@]} images verified"

      # 5. Generate summary
      - name: "[SUMMARY] Publication summary"
        run: |
          echo "📋 Generating publication summary..."
          
          # Create detailed summary
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## Dummy Docker Publication Test Results
          
          **Environment:** ${{ env.REGISTRY_ENV }}
          **Build Version:** ${{ env.BUILD_VERSION }}
          **Registry:** ${{ env.ARTIFACTORY_HOST }}
          **Test Status:** ✅ SUCCESS
          
          ### Published Dummy Images:
          
          | Image | Version Tag | Latest Tag | Size |
          |-------|-------------|------------|------|
          | onlysaid-app | ${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }} | ${{ env.REGISTRY_ENV }}-latest | ~5MB |
          | onlysaid-socket | ${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }} | ${{ env.REGISTRY_ENV }}-latest | ~5MB |
          | onlysaid-kb | ${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }} | ${{ env.REGISTRY_ENV }}-latest | ~5MB |
          | onlysaid-docs | ${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }} | ${{ env.REGISTRY_ENV }}-latest | ~5MB |
          
          ### Registry URLs:
          - App: \`${{ env.ARTIFACTORY_HOST }}/onlysaid-app:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}\`
          - Socket: \`${{ env.ARTIFACTORY_HOST }}/onlysaid-socket:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}\`
          - KB: \`${{ env.ARTIFACTORY_HOST }}/onlysaid-kb:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}\`
          - Docs: \`${{ env.ARTIFACTORY_HOST }}/onlysaid-docs:${{ env.REGISTRY_ENV }}-${{ env.BUILD_VERSION }}\`
          
          ### Configuration Details:
          - **JFrog Web URL:** ${{ env.JFROG_URL }}
          - **JFrog Artifactory URL:** ${{ env.JFROG_URL }}
          - **Docker Registry:** ${{ env.ARTIFACTORY_HOST }}
          - **Docker Login Host:** ${{ env.ARTIFACTORY_HOST }}
          
          ### Test Information:
          - **Purpose:** Test JFrog Docker registry publishing functionality
          - **Images:** Dummy Alpine Linux containers with metadata
          - **Authentication:** ✅ Successful
          - **Network Connectivity:** ✅ Successful
          - **Publishing:** ✅ Successful
          - **Method:** Repository Path (JFrog recommended)
          EOF
          
          echo "✅ Summary generated successfully"

      # 6. Cleanup
      - name: "[CLEANUP] Clean up dummy images"
        if: always()
        run: |
          echo "🧹 Cleaning up dummy Docker images..."
          
          # Restore original Docker daemon configuration
          if [ -f /etc/docker/daemon.json.backup ]; then
            echo "Restoring original Docker daemon configuration..."
            sudo mv /etc/docker/daemon.json.backup /etc/docker/daemon.json
            sudo systemctl restart docker
            sleep 10
          else
            echo "Removing Docker insecure registry configuration..."
            sudo rm -f /etc/docker/daemon.json
            sudo systemctl restart docker
            sleep 10
          fi
          
          # Logout from Docker registry
          docker logout "${{ env.ARTIFACTORY_HOST }}" || echo "Docker logout failed"
          
          # Remove dummy images
          echo "Removing dummy images..."
          docker images | grep "${{ env.ARTIFACTORY_HOST }}" | awk '{print $3}' | xargs -r docker rmi -f || echo "Some images couldn't be removed"
          
          # Clean up temporary Dockerfiles
          rm -f /tmp/Dockerfile.* || echo "No temporary Dockerfiles to clean"
          
          echo "✅ Cleanup completed" 