# OnlySaid GitLab CI/CD Pipeline
# Adapted from GitHub Actions workflow

# Global variables
variables:
  # Build versioning
  BUILD_VERSION: $CI_COMMIT_SHA
  BUILD_NUMBER: $CI_PIPELINE_IID
  
  # Docker registry configuration (HTTP port 8080)
  DOCKER_REGISTRY_HOST: "1bucket.oneas1a.com:8080"
  ELECTRON_REGISTRY: "oa-onlysaid-electron-dev-local"
  
  # Pipeline settings
  FF_USE_FASTZIP: "true"
  CACHE_COMPRESSION_LEVEL: "fast"
  
  # Enable Git submodules
  GIT_SUBMODULE_STRATEGY: recursive

# Stages definition
stages:
  - setup
  - test
  - build
  - package
  - publish
  - deploy
  - cleanup

# Default settings
default:
  # Use Node.js 22 on Debian 12 Bookworm (has GCC 12 with C++20 support)
  image: node:22-bookworm
  tags:
    - onlysaid-runner
  
  # Install additional tools needed across jobs
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq curl wget jq git build-essential
  
  # Retry configuration
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# Cache configuration
cache:
  - key: 
      files:
        - package-lock.json
    paths:
      - node_modules/
    policy: pull-push
  - key:
      files:
        - onlysaid-electron/package-lock.json
    paths:
      - onlysaid-electron/node_modules/
    policy: pull-push

# Job Templates
.load_secrets: &load_secrets
  - |
    echo "ðŸ”§ Using GitLab CI/CD variables..."
    
    # Configure Docker registry URLs
    export DOCKER_REGISTRY="${DOCKER_REGISTRY_HOST}/oa-onlysaid-app-docker-dev-local"
    
    echo "âœ… Configuration loaded successfully"
    echo "JFrog Web URL: ${JFROG_URL}"
    echo "Docker Registry Host: ${DOCKER_REGISTRY_HOST}"
    echo "Docker Registry: ${DOCKER_REGISTRY_HOST}/oa-onlysaid-app-docker-dev-local"
    echo "JFrog User: ${JFROG_USER}"

# For regular jobs (no Docker needed)
.verify_environment: &verify_environment
  - |
    echo "ðŸ” Verifying environment..."
    echo "Container OS: $(cat /etc/os-release | grep PRETTY_NAME)"
    echo "Current user: $(whoami)"
    echo "Working directory: $(pwd)"
    echo "Available disk space:"
    df -h
    echo "Node.js version:"
    node --version
    echo "npm version:"
    npm --version
    echo "Git version:"
    git --version
    echo "âœ… Environment verification completed"

# For Docker jobs (Docker commands available)
.verify_docker_environment: &verify_docker_environment
  - |
    echo "ðŸ” Verifying Docker environment..."
    echo "Container OS: $(cat /etc/os-release | grep PRETTY_NAME)"
    echo "Current user: $(whoami)"
    echo "Working directory: $(pwd)"
    echo "Available disk space:"
    df -h
    echo "Docker version:"
    docker --version
    echo "Docker info:"
    docker info
    echo "âœ… Docker environment verification completed"

.test_connectivity: &test_connectivity
  - |
    echo "ðŸ”— Testing JFrog connectivity..."
    
    # Test JFrog web interface connectivity (HTTPS for web API)
    WEB_URL="${JFROG_URL%/}/artifactory/api/system/ping"
    echo "Testing JFrog web interface: ${WEB_URL}"
    
    RETRY_COUNT=0
    MAX_RETRIES=3
    
    while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
      if curl -f -s -k --connect-timeout 10 --max-time 30 "${WEB_URL}" > /dev/null; then
        echo "âœ… JFrog web interface is accessible (attempt $((RETRY_COUNT + 1)))"
        break
      else
        RETRY_COUNT=$((RETRY_COUNT + 1))
        if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
          echo "âš ï¸ JFrog web interface connectivity failed, retrying in 5 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
          sleep 5
        else
          echo "âŒ Cannot reach JFrog web interface after $MAX_RETRIES attempts"
          echo "JFrog URL: ${JFROG_URL}"
          exit 1
        fi
      fi
    done
    
    echo "âœ… JFrog web interface connectivity verified"

# Jobs
setup:verify-environment:
  stage: setup
  script:
    - *load_secrets
    - *verify_environment
    - *test_connectivity
    - |
      echo "ðŸ”— Testing Docker registry connectivity early..."
      echo "Since publish-docker-artifacts.yml succeeds, this should also work"
      
      # Test Docker registry v2 API (HTTP on port 8080) WITH AUTHENTICATION
      DOCKER_V2_URL="http://$DOCKER_REGISTRY_HOST/v2/"
      echo "Testing Docker v2 API: $DOCKER_V2_URL"
      
      RETRY_COUNT=0
      MAX_RETRIES=5
      
      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        # Use authentication like the working test workflow does
        if curl -f -s -k -u "$JFROG_USER:$JFROG_USER_PASSWORD" --connect-timeout 15 --max-time 45 "$DOCKER_V2_URL" > /dev/null; then
          echo "âœ… Docker registry is accessible with authentication (attempt $((RETRY_COUNT + 1)))"
          break
        else
          RETRY_COUNT=$((RETRY_COUNT + 1))
          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            echo "âš ï¸ Docker registry connectivity failed, retrying in 10 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
            sleep 10
          else
            echo "âŒ Cannot reach Docker registry after $MAX_RETRIES attempts"
            echo "Docker Registry: $DOCKER_REGISTRY_HOST"
            echo "This should work since publish-docker-artifacts.yml succeeds"
            exit 1
          fi
        fi
      done
      
      echo "âœ… Early Docker registry connectivity test completed successfully"
  timeout: 10 minutes

install:nextjs-dependencies:
  stage: setup
  needs: ["setup:verify-environment"]
  script:
    - *load_secrets
    - |
      echo "Installing Next.js dependencies..."
      
      # Set npm configuration for better reliability
      npm config set fetch-timeout 60000
      npm config set fetch-retry-mintimeout 10000
      npm config set fetch-retry-maxtimeout 60000
      npm config set fetch-retries 3
      
      echo "Installing dependencies with npm ci..."
      npm ci --prefer-offline --no-audit
      echo "âœ… Successfully installed Next.js dependencies"
  timeout: 15 minutes
  cache:
    - key: 
        files:
          - package-lock.json
      paths:
        - node_modules/
      policy: push

install:electron-dependencies:
  stage: setup
  needs: ["setup:verify-environment"]
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq curl wget jq git
    # Manually checkout submodules
    - git submodule update --init --recursive
  script:
    - *load_secrets
    - |
      cd onlysaid-electron
      
      echo "Installing Electron dependencies..."
      
      # Set npm configuration for Electron
      npm config set fetch-timeout 60000
      npm config set fetch-retry-mintimeout 10000
      npm config set fetch-retry-maxtimeout 60000
      npm config set fetch-retries 3
      
      echo "Using public npm registry for Electron dependencies..."
      
      # Test connectivity
      echo "Testing npm registry connectivity for Electron..."
      timeout 30s npm ping
      
      echo "Installing Electron dependencies with npm ci..."
      npm ci --prefer-offline --no-audit
      echo "âœ… Successfully installed Electron dependencies"
  timeout: 15 minutes
  cache:
    - key:
        files:
          - onlysaid-electron/package-lock.json
      paths:
        - onlysaid-electron/node_modules/
      policy: push

test:lint-nextjs:
  stage: test
  needs: ["install:nextjs-dependencies"]
  script:
    - *load_secrets
    - |
      echo "Running Next.js ESLint..."
      npm run lint
      echo "âœ… Next.js ESLint passed"
  cache:
    - key: 
        files:
          - package-lock.json
      paths:
        - node_modules/
      policy: pull

test:nextjs:
  stage: test
  needs: ["install:nextjs-dependencies"]
  script:
    - *load_secrets
    - |
      echo "Running Next.js tests..."
      # Uncomment when tests are available
      # npm test
      echo "âœ… Next.js tests completed (no tests configured yet)"
  cache:
    - key: 
        files:
          - package-lock.json
      paths:
        - node_modules/
      policy: pull

test:electron:
  stage: test
  needs: ["install:electron-dependencies"]
  script:
    - *load_secrets
    - |
      echo "Skipping Electron tests - will be run during package build"
      echo "âœ… Electron tests will be handled by package script"

build:nextjs:
  stage: build
  needs: ["test:lint-nextjs", "test:nextjs"]
  script:
    - *load_secrets
    - |
      echo "Building Next.js..."
      npm run build
      echo "âœ… Next.js application built successfully"
  variables:
    NODE_ENV: production
  cache:
    - key: 
        files:
          - package-lock.json
      paths:
        - node_modules/
      policy: pull

package:electron:
  stage: package
  needs: ["test:electron"]
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq curl wget jq git
    # Manually checkout submodules
    - git submodule update --init --recursive
  script:
    - *load_secrets
    - |
      echo "Current working directory: $(pwd)"
      echo "Repository contents:"
      ls -la
      echo "Verifying onlysaid-electron directory exists:"
      if [ ! -d "onlysaid-electron" ]; then
        echo "âŒ onlysaid-electron directory not found"
        exit 1
      fi
      echo "âœ… onlysaid-electron directory found"
    - |
      cd onlysaid-electron
      echo "Building Electron application..."
      echo "Current working directory: $(pwd)"
      echo "Directory contents:"
      ls -la
      echo "Checking if package.json exists:"
      if [ -f "package.json" ]; then
        echo "âœ… package.json found"
        echo "Available npm scripts:"
        npm run
      else
        echo "âŒ package.json not found"
        exit 1
      fi
      echo "Checking node_modules:"
      if [ -d "node_modules" ]; then
        echo "âœ… node_modules directory exists"
      else
        echo "âŒ node_modules directory missing"
        echo "Re-running npm install..."
        npm install
      fi
      npm run package
      echo "âœ… Electron build completed successfully"
  variables:
    KB_BASE_URL: ${KB_BASE_URL:-"https://onlysaid.com/api/kb"}
    MICROSOFT_CLIENT_ID: ${MICROSOFT_CLIENT_ID:-"4b24891c-a62b-4da5-9fd1-fc6e1b912297"}
    ONLYSAID_API_URL: ${ONLYSAID_API_URL:-"https://onlysaid.com/api/v2"}
    ONLYSAID_DOMAIN: ${ONLYSAID_DOMAIN:-"https://onlysaid.com"}
    SOCKET_SERVER_URL: ${SOCKET_SERVER_URL:-"https://onlysaid.com/"}
    GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID:-"879402396826-sfq4ukdf1luhh5o0ub0am7gnljce2ss5.apps.googleusercontent.com"}
    GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET:-""}
  artifacts:
    name: "electron-installers-$BUILD_VERSION"
    paths:
      - onlysaid-electron/release/build/
    expire_in: 7 days
  cache:
    - key:
        files:
          - onlysaid-electron/package-lock.json
      paths:
        - onlysaid-electron/node_modules/
      policy: pull

build:docker-images:
  stage: build
  needs: ["build:nextjs"]
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - apk add --no-cache curl bash jq
    - *load_secrets
    - *verify_docker_environment
  script:
    - |
      echo "Building Docker images..."
      
      # Build Next.js Docker Image
      docker build -t "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-app:dev-$BUILD_VERSION" \
        -f ./docker/Dockerfile.next .
      
      # Build Socket Server Docker Image
      docker build -t "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-socket:dev-$BUILD_VERSION" \
        -f ./socket_server/Dockerfile.socket_server ./socket_server/
      
      # Build Knowledge Base Docker Image
      docker build -t "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-kb:dev-$BUILD_VERSION" \
        -f ./docker/Dockerfile.kb .
      
      # Build Documentation Docker Image
      docker build -t "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-docs:dev-$BUILD_VERSION" \
        -f ./docker/Dockerfile.docs .
      
      # Save images as tar files for artifacts
      docker save "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-app:dev-$BUILD_VERSION" > onlysaid-app.tar
      docker save "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-socket:dev-$BUILD_VERSION" > onlysaid-socket.tar
      docker save "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-kb:dev-$BUILD_VERSION" > onlysaid-kb.tar
      docker save "$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-docs:dev-$BUILD_VERSION" > onlysaid-docs.tar
      
      echo "âœ… All Docker images built successfully"
  artifacts:
    name: "docker-images-$BUILD_VERSION"
    paths:
      - "*.tar"
    expire_in: 7 days

publish:docker-images:
  stage: publish
  needs: ["build:docker-images"]
  before_script:
    - *load_secrets
  script:
    - |
      echo "ðŸš€ Uploading Docker images to JFrog..."
      
      # No need to configure Docker daemon for insecure registries
      # since we're using the host's Docker directly
      
      # Load Docker images from tar files
      echo "ðŸ“¦ Loading Docker images..."
      docker load < onlysaid-app.tar
      docker load < onlysaid-socket.tar
      docker load < onlysaid-kb.tar
      docker load < onlysaid-docs.tar
      
      # Docker login with retry logic
      echo "ðŸ” Authenticating with JFrog Docker registry..."
      
      LOGIN_ATTEMPTS=0
      MAX_LOGIN_ATTEMPTS=3
      
      while [ $LOGIN_ATTEMPTS -lt $MAX_LOGIN_ATTEMPTS ]; do
        if echo "$JFROG_USER_PASSWORD" | docker login "$DOCKER_REGISTRY_HOST" -u "$JFROG_USER" --password-stdin; then
          echo "âœ… Successfully authenticated with JFrog Docker Registry"
          break
        else
          LOGIN_ATTEMPTS=$((LOGIN_ATTEMPTS + 1))
          if [ $LOGIN_ATTEMPTS -lt $MAX_LOGIN_ATTEMPTS ]; then
            echo "âš ï¸ Login attempt $LOGIN_ATTEMPTS failed, retrying in 10 seconds..."
            sleep 10
          else
            echo "âŒ Failed to authenticate after $MAX_LOGIN_ATTEMPTS attempts"
            exit 1
          fi
        fi
      done
      
      # Function to push with retry logic
      push_with_retry() {
        local image_tag="$1"
        local max_attempts=3
        local attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Attempt $attempt/$max_attempts: Pushing $image_tag"
          
          if timeout 600 docker push "$image_tag" 2>&1 | tee /tmp/push_log_${attempt}.txt; then
            echo "âœ… Successfully pushed $image_tag on attempt $attempt"
            return 0
          else
            echo "âŒ Push attempt $attempt failed for $image_tag"
            
            if [ $attempt -lt $max_attempts ]; then
              echo "Waiting 30 seconds before retry..."
              sleep 30
            fi
            
            attempt=$((attempt + 1))
          fi
        done
        
        echo "âŒ Failed to push $image_tag after $max_attempts attempts"
        return 1
      }
      
      # Push images with error handling
      echo "ðŸ“¤ Pushing Docker images..."
      IMAGES=("onlysaid-app" "onlysaid-socket" "onlysaid-kb" "onlysaid-docs")
      PUSHED_COUNT=0
      FAILED_PUSHES=()
      
      for image in "${IMAGES[@]}"; do
        IMAGE_TAG="$DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/${image}:dev-$BUILD_VERSION"
        echo "Pushing ${IMAGE_TAG}..."
        
        if push_with_retry "${IMAGE_TAG}"; then
          echo "âœ… Successfully pushed ${image}"
          PUSHED_COUNT=$((PUSHED_COUNT + 1))
        else
          echo "âŒ Failed to push ${image}"
          FAILED_PUSHES+=("$image")
        fi
      done
      
      # Report results
      echo "ðŸ“Š Push Results:"
      echo "Successfully pushed: $PUSHED_COUNT/${#IMAGES[@]}"
      
      if [ ${#FAILED_PUSHES[@]} -gt 0 ]; then
        echo "Failed pushes: ${FAILED_PUSHES[*]}"
        echo "âŒ Some images failed to push"
        exit 1
      else
        echo "âœ… All images pushed successfully"
      fi

publish:electron-installers:
  stage: publish
  needs: ["package:electron"]
  script:
    - *load_secrets
    - |
      echo "Uploading Electron installers to oa-onlysaid-electron-dev-local..."
      echo "Using HTTP (port 8080) method like Docker registry"
      
      cd onlysaid-electron/release/build
      
      # Use HTTP URL (port 8080) instead of HTTPS
      JFROG_HTTP_URL="http://1bucket.oneas1a.com:8080"
      echo "JFrog HTTP URL: ${JFROG_HTTP_URL}"
      echo "Target registry: $ELECTRON_REGISTRY"
      echo "Build version: $BUILD_VERSION"
      
      # Verify that build artifacts exist
      if [ ! "$(ls -A .)" ]; then
        echo "âŒ No Electron build artifacts found"
        exit 1
      fi
      
      # Upload all built installers to electron registry using HTTP
      UPLOADED_COUNT=0
      FAILED_UPLOADS=()
      
      for file in *.exe *.dmg *.AppImage *.deb *.rpm; do
        if [ -f "$file" ]; then
          echo "ðŸ“¤ Uploading $file to $ELECTRON_REGISTRY..."
          
          # Method 1: Try with JFrog CLI using HTTP URL and insecure flag
          if jfrog rt u "$file" "$ELECTRON_REGISTRY/v$BUILD_VERSION/$file" \
            --url="${JFROG_HTTP_URL}" \
            --user="$JFROG_USER" \
            --password="$JFROG_USER_PASSWORD" \
            --insecure-tls=true \
            --build-name="OnlySaid-Electron" \
            --build-number="$BUILD_NUMBER"; then
            echo "âœ… Successfully uploaded $file with JFrog CLI"
            UPLOADED_COUNT=$((UPLOADED_COUNT + 1))
          else
            echo "âš ï¸ JFrog CLI failed, trying with curl..."
            
            # Method 2: Fallback to curl (like working test)
            TARGET_PATH="artifactory/$ELECTRON_REGISTRY/v$BUILD_VERSION/$file"
            CURL_URL="${JFROG_HTTP_URL}/${TARGET_PATH}"
            
            echo "Uploading with curl to: ${CURL_URL}"
            
            if curl -f -u "$JFROG_USER:$JFROG_USER_PASSWORD" \
              -T "$file" \
              --connect-timeout 30 \
              --max-time 300 \
              "${CURL_URL}"; then
              echo "âœ… Successfully uploaded $file with curl"
              UPLOADED_COUNT=$((UPLOADED_COUNT + 1))
            else
              echo "âŒ Failed to upload $file with both methods"
              FAILED_UPLOADS+=("$file")
            fi
          fi
        fi
      done
      
      # Report results
      echo "ðŸ“Š Upload Results:"
      echo "Successfully uploaded: $UPLOADED_COUNT files"
      
      if [ ${#FAILED_UPLOADS[@]} -gt 0 ]; then
        echo "Failed uploads: ${FAILED_UPLOADS[*]}"
        echo "âŒ Some Electron installers failed to upload"
        exit 1
      else
        echo "âœ… All Electron installers uploaded successfully"
      fi

deploy:generate-manifests:
  stage: deploy
  needs: ["publish:docker-images"]
  script:
    - *load_secrets
    - |
      echo "Generating Kubernetes deployment manifests..."
      mkdir -p k8s-manifests
      
      # Create deployment manifest template using correct docker registry
      cat > k8s-manifests/onlysaid-app-deployment.yaml << EOF
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: onlysaid-app-dev
        namespace: onlysaid-dev
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: onlysaid-app-dev
        template:
          metadata:
            labels:
              app: onlysaid-app-dev
          spec:
            containers:
            - name: onlysaid-app
              image: $DOCKER_REGISTRY_HOST/oa-onlysaid-app-docker-dev-local/onlysaid-app:dev-$BUILD_VERSION
              ports:
              - containerPort: 3000
      EOF
      echo "âœ… Kubernetes manifests generated"
  artifacts:
    name: "k8s-manifests-$BUILD_VERSION"
    paths:
      - k8s-manifests/
    expire_in: 7 days

# Summary job
build-summary:
  stage: deploy
  needs: 
    - "publish:docker-images"
    - "publish:electron-installers" 
    - "deploy:generate-manifests"
  script:
    - *load_secrets
    - |
      echo "## Build Summary"
      echo "- **Build Version:** $BUILD_VERSION"
      echo "- **Build Number:** $BUILD_NUMBER"
      echo "- **Pipeline ID:** $CI_PIPELINE_ID"
      echo "- **Runner Type:** Self-hosted Linux"
      echo "- **Runner Host:** $(hostname)"
      echo "- **JFrog Web URL:** $JFROG_URL"
      echo "- **Docker Registry Host:** $DOCKER_REGISTRY_HOST"
      echo "- **Docker Registry:** $DOCKER_REGISTRY"
      echo "- **JFrog Configured:** âœ…"
      echo "- **JFrog Accessible:** âœ…"
      echo "- **Docker Registry Accessible:** âœ…"
      echo "- **Docker Repository:** oa-onlysaid-app-docker-dev-local"
      echo "- **Electron Registry:** oa-onlysaid-electron-dev-local"
      echo "- **Docker Images Built:** âœ…"
      echo "- **Electron Build Completed:** âœ…"
      echo "- **Artifacts Published to JFrog:** âœ…"

# Cleanup job - always runs
cleanup:workspace:
  stage: cleanup
  when: always
  script:
    - |
      echo "ðŸ§¹ Cleaning up..."
      
      # Clean up JFrog configuration
      if [ -n "${JFROG_SERVER_ID}" ]; then
        echo "Cleaning up JFrog configuration..."
        jfrog config remove "${JFROG_SERVER_ID}" --quiet || echo "JFrog config cleanup failed"
      fi
      
      # Logout from Docker registry
      docker logout "$DOCKER_REGISTRY_HOST" || echo "Docker logout failed"
      
      # Clean up Docker images to save space
      echo "Cleaning up Docker images..."
      docker system prune -f
      
      # Clean up npm cache
      echo "Cleaning npm cache..."
      npm cache clean --force
      
      # Clean up node_modules to save space (will be reinstalled next run)
      echo "Cleaning node_modules..."
      rm -rf node_modules
      rm -rf onlysaid-electron/node_modules
      
      # Clean up build artifacts
      echo "Cleaning build artifacts..."
      rm -rf .next
      rm -rf onlysaid-electron/release
      rm -rf *.tar
      
      # Clean up temporary files
      echo "Cleaning temporary files..."
      rm -rf .npmrc
      
      echo "âœ… Workspace cleanup completed"

# Rules for when to run the pipeline
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH == "development"
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "development" 